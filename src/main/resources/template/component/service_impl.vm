package ${PackageId}.application.service.impl;

import ${PackageId}.application.exception.InvalidInputException;
import ${PackageId}.application.service.${ResourceSingular}Service;
import ${PackageId}.application.utility.SecurityUtil;
import ${PackageId}.configuration.aop.annotation.LogMethodInfo;
import ${PackageId}.domain.${ResourceAllSmallCase}.*;
import ${PackageId}.domain.${ResourceAllSmallCase}.repository.${ResourceSingular}Repository;

import com.google.common.collect.Lists;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

@Service
@Transactional
@LogMethodInfo
public class ${ResourceSingular}ServiceImpl implements ${ResourceSingular}Service {


    @Autowired
    private ${ResourceSingular}Repository ${ResourceSmallCase}Repository;

    @Override
    public List<${ResourceSingular}> save${ResourcePlural}(List<${ResourceSingular}> ${ResourceSmallCase}List) {
        ${ResourceSmallCase}List.forEach(this::initAuditFields);
        return ${ResourceSmallCase}Repository.saveAll(${ResourceSmallCase}List);
    }

    @Override
    public List<${ResourceSingular}> update${ResourcePlural}(List<${ResourceSingular}> ${ResourceSmallCase}List) {
        List<${ResourceSingular}> valid${ResourceSingular}List = validateData(${ResourceSmallCase}List);
        return ${ResourceSmallCase}Repository.saveAll(valid${ResourceSingular}List);
    }


    @Override
    public String delete${ResourcePlural}(String[] ${ResourceSmallCase}Ids) {
    #if($EnableHardDelete)
     ${ResourceSmallCase}Repository.deleteAll(get${ResourcePlural}(${ResourceSmallCase}Ids));
    #else
         List<${ResourceSingular}> deactivatedObjects = get${ResourcePlural}(${ResourceSmallCase}Ids).stream().peek(it -> {
                 it.isActive = Boolean.FALSE;
                 if (it.additionalProperties == null || it.additionalProperties.isEmpty())
                      it.additionalProperties = Collections.singletonMap("InActiveDateTime", new Date());
                  else
                      it.additionalProperties.put("InActiveDateTime", new Date());
         }).collect(Collectors.toList());

     ${ResourceSmallCase}Repository.saveAll(deactivatedObjects);
    #end
        return "Success";
    }

    @Override
    public List<${ResourceSingular}> getAll${ResourcePlural}() {
        return ${ResourceSmallCase}Repository.findAll();
    }

    @Override
    public List<${ResourceSingular}> get${ResourcePlural}(String[] ${ResourceSmallCase}Ids) {
        Iterable<String> values = new HashSet<>(Arrays.asList(${ResourceSmallCase}Ids));
        Iterable<${ResourceSingular}> resultItr = ${ResourceSmallCase}Repository.findAllById(values);
        return Lists.newArrayList(resultItr);
    }

#foreach ($subDomain in  ${SubDomainList})
    @Override
    public ${ResourceSingular} save${ResourceSingular}$subDomain(String ${ResourceSmallCase}Id, $subDomain ${AttributeHelper.getResourceNameSubDomainSingular($subDomain)}){
        Optional<${ResourceSingular}> result = ${ResourceSmallCase}Repository.findById(${ResourceSmallCase}Id);
        if (!result.isPresent()) {
            throw new InvalidInputException("Id should be a valid existing DocumentId");
        }
        updateAuditFields(result.get());
        result.get().${AttributeHelper.getResourceNameSubDomainSingular($subDomain)}.add(${AttributeHelper.getResourceNameSubDomainSingular($subDomain)});
        return ${ResourceSmallCase}Repository.save(result.get());
    }

     @Override
     public ${ResourceSingular} update${ResourceSingular}$subDomain(String ${ResourceSmallCase}Id, $subDomain ${AttributeHelper.getResourceNameSubDomainSingular($subDomain)}) {
            Optional<${ResourceSingular}> result = ${ResourceSmallCase}Repository.findBy_idAnd${subDomain}__id(${ResourceSmallCase}Id, ${AttributeHelper.getResourceNameSubDomainSingular($subDomain)}._id);
            if (!result.isPresent()) {
                throw new InvalidInputException("Id should be a valid existing DocumentId");
            }
            ${ResourceSingular} resultObject = result.get();
            List<$subDomain> updatedList =
                    resultObject.${AttributeHelper.getResourceNameSubDomainSingular($subDomain)}.stream().filter(it -> !it._id.equals(${AttributeHelper.getResourceNameSubDomainSingular($subDomain)}._id))
                            .collect(Collectors.toList());
            updatedList.add(${AttributeHelper.getResourceNameSubDomainSingular($subDomain)});
            resultObject.${AttributeHelper.getResourceNameSubDomainSingular($subDomain)}.clear();
            resultObject.${AttributeHelper.getResourceNameSubDomainSingular($subDomain)}.addAll(updatedList);
            updateAuditFields(resultObject);
            return ${ResourceSmallCase}Repository.save(resultObject);
     }


    @Override
    public String delete${ResourceSingular}$subDomain(String ${ResourceSmallCase}Id, String ${AttributeHelper.getResourceNameSubDomainSingular($subDomain)}Id){
             Optional<${ResourceSingular}> result = ${ResourceSmallCase}Repository.findBy_idAnd${subDomain}__id(${ResourceSmallCase}Id, ${AttributeHelper.getResourceNameSubDomainSingular($subDomain)}Id);
             if (!result.isPresent()) {
                 throw new InvalidInputException("Id should be a valid existing DocumentId");
             }
             ${ResourceSingular} resultObject = result.get();
             List<$subDomain> updatedList =
                     resultObject.${AttributeHelper.getResourceNameSubDomainSingular($subDomain)}.stream().filter(it -> !it._id.equals(${AttributeHelper.getResourceNameSubDomainSingular($subDomain)}Id))
                             .collect(Collectors.toList());
             resultObject.${AttributeHelper.getResourceNameSubDomainSingular($subDomain)}.clear();
             resultObject.${AttributeHelper.getResourceNameSubDomainSingular($subDomain)}.addAll(updatedList);
             updateAuditFields(resultObject);
             ${ResourceSmallCase}Repository.save(resultObject);
             return "Success";
    }


#end

    private List<${ResourceSingular}> validateData(List<${ResourceSingular}> ${ResourceSmallCase}List) {
        return ${ResourceSmallCase}List.stream().filter(${ResourceSmallCase} -> {
            if (null != ${ResourceSmallCase}._id && !${ResourceSmallCase}._id.isEmpty()) {
                Optional<${ResourceSingular}> fetched${ResourceSingular} = ${ResourceSmallCase}Repository.findById(${ResourceSmallCase}._id);
                if (fetched${ResourceSingular}.isPresent()) {
                    updateAuditFields(${ResourceSmallCase}, fetched${ResourceSingular}.get());
                    return true;
                }
                throw new InvalidInputException("Id should be a valid DocumentId");
            } else
                throw new InvalidInputException("Id must not be null");

        }).collect(Collectors.toList());
    }

     private void initAuditFields(${ResourceSingular} ${ResourceSmallCase}){
             ${ResourceSmallCase}.createdByUser = SecurityUtil.loggedInUser().getUserId();
             ${ResourceSmallCase}.createdDateTime = new Date();
             ${ResourceSmallCase}.updatedDateTime = null;
             ${ResourceSmallCase}._id = null;
             ${ResourceSmallCase}.isActive =  Boolean.TRUE;
     }

     private void updateAuditFields(${ResourceSingular} newValue, ${ResourceSingular} existingValue) {
            newValue.createdDateTime = existingValue.createdDateTime;
            newValue.createdByUser = existingValue.createdByUser;
            newValue.updatedByUser = SecurityUtil.loggedInUser().getUserId();
            newValue.updatedDateTime = new Date();
     }

     private void updateAuditFields(${ResourceSingular} ${ResourceSmallCase}) {
            ${ResourceSmallCase}.updatedByUser = SecurityUtil.loggedInUser().getUserId();
            ${ResourceSmallCase}.updatedDateTime = new Date();
     }
}

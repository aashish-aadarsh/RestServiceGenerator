package ${PackageId}.application.service.impl;

import ${PackageId}.application.exception.InvalidInputException;
import ${PackageId}.application.constant.ConfigConstant;

import ${PackageId}.application.service.${ResourceSingular}Service;
import ${PackageId}.application.utility.SecurityUtil;
import ${PackageId}.configuration.aop.annotation.LogMethodInfo;
import ${PackageId}.domain.${ResourceAllSmallCase}.*;
import ${PackageId}.domain.${ResourceAllSmallCase}.repository.${ResourceSingular}Repository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.google.common.collect.Lists;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.bson.types.ObjectId;
import java.util.*;
import java.util.stream.Collectors;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;


@Service
@Transactional
@LogMethodInfo
public class ${ResourceSingular}ServiceImpl implements ${ResourceSingular}Service {

    private static final Logger logger = LoggerFactory.getLogger(${ResourceSingular}ServiceImpl.class);

    @Autowired
    private ${ResourceSingular}Repository ${ResourceSmallCase}Repository;

    @Override
    public List<${ResourceSingular}> save${ResourcePlural}(List<${ResourceSingular}> ${ResourceSmallCase}List) {
        ${ResourceSmallCase}List.forEach(this::initAuditFields);
        return ${ResourceSmallCase}Repository.saveAll(${ResourceSmallCase}List);
    }

    @Override
    public List<${ResourceSingular}> update${ResourcePlural}(List<${ResourceSingular}> ${ResourceSmallCase}List) {
        List<${ResourceSingular}> valid${ResourceSingular}List = validateData(${ResourceSmallCase}List);
        return ${ResourceSmallCase}Repository.saveAll(valid${ResourceSingular}List);
    }


    @Override
    public String delete${ResourcePlural}(String[] ${ResourceSmallCase}Ids) {
    #if($EnableHardDelete)
     ${ResourceSmallCase}Repository.deleteAll(get${ResourcePlural}(${ResourceSmallCase}Ids));
    #else
         List<${ResourceSingular}> deactivatedObjects = get${ResourcePlural}(${ResourceSmallCase}Ids).stream().peek(it -> {
                 it.isActive = Boolean.FALSE;
                 if (it.additionalProperties == null || it.additionalProperties.isEmpty())
                      it.additionalProperties = Collections.singletonMap("InActiveDateTime", new Date());
                  else
                      it.additionalProperties.put("InActiveDateTime", new Date());
         }).collect(Collectors.toList());

     ${ResourceSmallCase}Repository.saveAll(deactivatedObjects);
    #end
        return "Success";
    }

    @Override
    public List<${ResourceSingular}> getAll${ResourcePlural}() {
        return ${ResourceSmallCase}Repository.findAll();
    }

    @Override
    public Page<${ResourceSingular}> getAll${ResourcePlural}PageAble(Integer pageIndex, Integer pageSize, String direction, String[] fields) {
        Pageable pageRequest;
        if (null == pageIndex || pageIndex < 0)
            pageIndex = ConfigConstant.DEFAULT_PAGE_INDEX;

        if (null == pageSize || pageSize <= 0 || pageSize > ConfigConstant.MAXIMUM_PAGE_SIZE)
            pageSize = ConfigConstant.MAXIMUM_PAGE_SIZE;

        if (null != direction && null != fields && fields.length != 0)
            pageRequest = PageRequest.of(pageIndex, pageSize, Sort.Direction.fromString(direction), fields);
        else {
            pageRequest = PageRequest.of(pageIndex, pageSize);
        }
        return ${ResourceSmallCase}Repository.findAll(pageRequest);
    }

    @Override
    public List<${ResourceSingular}> get${ResourcePlural}(String[] ${ResourceSmallCase}Ids) {
        Iterable<String> values = new HashSet<>(Arrays.asList(${ResourceSmallCase}Ids));
        Iterable<${ResourceSingular}> resultItr = ${ResourceSmallCase}Repository.findAllById(values);
        return Lists.newArrayList(resultItr);
    }

#foreach ($subDomain in  ${SubDomainList})
    #set( $subDomainName = ${AttributeHelper.getSubDomainName($subDomain)} )
    #set( $subDomainResourceName  = ${AttributeHelper.getResourceNameSubDomainSingular($subDomainName)})
    #set( $subDomainResourceKeyGetter = ${AttributeHelper.getResourceNameSubDomainGetter($subDomain)})
    #set( $subDomainResourceNameRepo  = ${AttributeHelper.getResourceNameSubDomainGetter($subDomain)})
    @Override
    public ${ResourceSingular} save${ResourceSingular}$subDomainName(String ${ResourceSmallCase}Id, $subDomainName $subDomainResourceName){
        Optional<${ResourceSingular}> result = ${ResourceSmallCase}Repository.findById(${ResourceSmallCase}Id);
        if (!result.isPresent()) {
            throw new InvalidInputException("Id should be a valid existing DocumentId");
        }
        logger.debug("Fetched Result From DB for adding child entity...{}", result.get());
        updateAuditFields(result.get());
        ${subDomainResourceName}._id = new ObjectId().toString();

         if(result.get().get${subDomainResourceKeyGetter}()!=null)
             result.get().get${subDomainResourceKeyGetter}().add(${AttributeHelper.getResourceNameSubDomainSingular($subDomainName)});
         else
             result.get().set${subDomainResourceKeyGetter}(Collections.singletonList(${AttributeHelper.getResourceNameSubDomainSingular($subDomainName)}));

        return ${ResourceSmallCase}Repository.save(result.get());
    }

     @Override
     public ${ResourceSingular} update${ResourceSingular}$subDomainName(String ${ResourceSmallCase}Id, $subDomainName $subDomainResourceName) {
            Optional<${ResourceSingular}> result = ${ResourceSmallCase}Repository.findBy_idAnd${subDomainResourceNameRepo}__id(${ResourceSmallCase}Id, ${subDomainResourceName}._id);
            if (!result.isPresent()) {
                throw new InvalidInputException("Id should be a valid existing DocumentId");
            }
            logger.debug("Fetched Result From DB for updating child entity...{}", result.get());
            ${ResourceSingular} resultObject = result.get();
            List<$subDomainName> updatedList =
                    resultObject.get${subDomainResourceKeyGetter}().stream().filter(it -> !it._id.equals(${subDomainResourceName}._id))
                            .collect(Collectors.toList());
            updatedList.add($subDomainResourceName);
            resultObject.get${subDomainResourceKeyGetter}().clear();
            resultObject.get${subDomainResourceKeyGetter}().addAll(updatedList);
            updateAuditFields(resultObject);
            return ${ResourceSmallCase}Repository.save(resultObject);
     }


    @Override
    public String delete${ResourceSingular}$subDomainName(String ${ResourceSmallCase}Id, String  ${subDomainResourceName}Id){
             Optional<${ResourceSingular}> result = ${ResourceSmallCase}Repository.findBy_idAnd${subDomainResourceNameRepo}__id(${ResourceSmallCase}Id, ${subDomainResourceName}Id);
             if (!result.isPresent()) {
                 throw new InvalidInputException("Id should be a valid existing DocumentId");
             }
             logger.debug("Fetched Result From DB for deleting child entity...{}", result.get());
             ${ResourceSingular} resultObject = result.get();
             List<$subDomainName> updatedList =
                     resultObject.get${subDomainResourceKeyGetter}().stream().filter(it -> !it._id.equals(${subDomainResourceName}Id))
                             .collect(Collectors.toList());
             resultObject.get${subDomainResourceKeyGetter}().clear();
             resultObject.get${subDomainResourceKeyGetter}().addAll(updatedList);
             updateAuditFields(resultObject);
             ${ResourceSmallCase}Repository.save(resultObject);
             return "Success";
    }


#end

    private List<${ResourceSingular}> validateData(List<${ResourceSingular}> ${ResourceSmallCase}List) {
        return ${ResourceSmallCase}List.stream().filter(${ResourceSmallCase} -> {
            if (null != ${ResourceSmallCase}._id && !${ResourceSmallCase}._id.isEmpty()) {
                Optional<${ResourceSingular}> fetched${ResourceSingular} = ${ResourceSmallCase}Repository.findById(${ResourceSmallCase}._id);
                if (fetched${ResourceSingular}.isPresent()) {
                    updateAuditFields(${ResourceSmallCase}, fetched${ResourceSingular}.get());
                    return true;
                }
                throw new InvalidInputException("Id should be a valid DocumentId");
            } else
                throw new InvalidInputException("Id must not be null");

        }).collect(Collectors.toList());
    }

     private void initAuditFields(${ResourceSingular} ${ResourceSmallCase}){
             ${ResourceSmallCase}.createdByUser = SecurityUtil.loggedInUser().getUserId();
             ${ResourceSmallCase}.createdDateTime = new Date();
             ${ResourceSmallCase}.updatedDateTime = null;
             ${ResourceSmallCase}._id = null;
             ${ResourceSmallCase}.isActive =  Boolean.TRUE;
     }

     private void updateAuditFields(${ResourceSingular} newValue, ${ResourceSingular} existingValue) {
            newValue.createdDateTime = existingValue.createdDateTime;
            newValue.createdByUser = existingValue.createdByUser;
            newValue.updatedByUser = SecurityUtil.loggedInUser().getUserId();
            newValue.updatedDateTime = new Date();
     }

     private void updateAuditFields(${ResourceSingular} ${ResourceSmallCase}) {
            ${ResourceSmallCase}.updatedByUser = SecurityUtil.loggedInUser().getUserId();
            ${ResourceSmallCase}.updatedDateTime = new Date();
     }
}
